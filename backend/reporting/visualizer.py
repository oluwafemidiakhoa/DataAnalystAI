# backend/reporting/visualizer.py
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import logging
from typing import Dict, Any, Optional, Union, List
import json # Needed for parsing chart JSON in reports

# Assuming LLM utils are available
try:
    from backend.llm.gemini_utils import suggest_visualization_llm
    LLM_AVAILABLE = True
except ImportError:
    LLM_AVAILABLE = False
    logger = logging.getLogger(__name__) # Define logger if import fails
    logger.error("LLM utility function suggest_visualization_llm not found.", exc_info=True)
    # Define mock
    def suggest_visualization_llm(context, available_columns):
        logger.warning("Using MOCK suggest_visualization_llm.")
        # Simple fallback suggestion based on columns
        if len(available_columns) >= 2: return {"chart_type": "scatter", "x_column": available_columns[0], "y_column": available_columns[1], "rationale": "Mock scatter"}
        elif len(available_columns) >= 1: return {"chart_type": "histogram", "x_column": available_columns[0], "y_column": None, "rationale": "Mock histogram"}
        else: return {"error": "Mock needs at least one column."}

logger = logging.getLogger(__name__)

# --- Constants for Supported Chart Types ---
# Helps with validation and UI generation
SUPPORTED_CHART_TYPES = [
    "bar", "line", "scatter", "pie", "histogram", "box", "violin",
    "density_heatmap", "density_contour", "scatter_3d", "line_3d",
    "scatter_geo", "choropleth", # Geo charts require specific columns
    "treemap", "sunburst" # Hierarchical charts
]

# --- Visualization Suggestion ---
def suggest_visualization(df: pd.DataFrame, nl_query_context: Optional[str] = None) -> Dict[str, Any]:
    """
    Suggests an appropriate visualization type and columns using an LLM.
    Includes validation against supported chart types.
    """
    if df is None or df.empty:
        logger.warning("Cannot suggest visualization for empty DataFrame.")
        return {"error": "Input data is empty."}

    logger.info(f"Generating visualization suggestion for DataFrame shape {df.shape}. Context: {nl_query_context or 'N/A'}")

    # Prepare context for LLM (as before)
    data_sample = df.head().to_markdown(index=False, numalign="left", stralign="left")
    schema = ", ".join([f"{col} ({str(dtype)})" for col, dtype in df.dtypes.items()])
    num_rows = len(df); available_columns = list(df.columns)
    context = f"Dataset Info:\n- Shape: {num_rows} rows, {len(available_columns)} columns\n"
    context += f"- Columns & Types: {schema}\n"
    if nl_query_context: context += f"- Analysis Context/Query: {nl_query_context}\n"
    context += f"- Data Sample:\n{data_sample}\n"
    # Add list of supported types to prompt
    context += f"\nSupported Chart Types: {', '.join(SUPPORTED_CHART_TYPES)}"


    if not LLM_AVAILABLE:
        logger.warning("LLM not available, using basic heuristic for visualization suggestion.")
        # Basic heuristic fallback (similar to mock)
        if len(available_columns) >= 2: suggestion_dict = {"chart_type": "scatter", "x_column": available_columns[0], "y_column": available_columns[1], "rationale": "Heuristic: Scatter for two columns."}
        elif len(available_columns) >= 1: suggestion_dict = {"chart_type": "histogram", "x_column": available_columns[0], "y_column": None, "rationale": "Heuristic: Histogram for one column."}
        else: suggestion_dict = {"error": "Heuristic needs at least one column."}
        # Add default keys if needed by heuristic fallback
        suggestion_dict.setdefault('color_column', None)
        if 'error' not in suggestion_dict: suggestion_dict.setdefault('rationale', "Generated by basic heuristic.")
        return suggestion_dict

    # --- Call LLM ---
    try:
        # The LLM function should be prompted to return one of the SUPPORTED_CHART_TYPES
        suggestion_dict = suggest_visualization_llm(context, available_columns)

        # --- Validate Suggestion ---
        if not isinstance(suggestion_dict, dict): raise ValueError("AI suggestion format was invalid (not a dict).")
        if "error" in suggestion_dict: return suggestion_dict # Pass through LLM error

        required_keys = ["chart_type", "x_column", "y_column", "rationale"]
        if not all(key in suggestion_dict for key in required_keys): raise ValueError("AI suggestion incomplete (missing required keys).")

        # Validate chart type
        suggested_type = suggestion_dict.get("chart_type")
        if suggested_type and suggested_type not in SUPPORTED_CHART_TYPES:
             logger.warning(f"LLM suggested unsupported chart type '{suggested_type}'. Attempting fallback.")
             # Simple fallback: histogram if x exists, else error
             if suggestion_dict.get("x_column") and suggestion_dict["x_column"] in available_columns:
                  suggestion_dict["chart_type"] = "histogram"
                  suggestion_dict["y_column"] = None # Ensure y is None for histogram
                  suggestion_dict["rationale"] += f" (Fell back to histogram from unsupported '{suggested_type}')"
             else:
                  return {"error": f"AI suggested unsupported chart type '{suggested_type}' and fallback failed."}

        # Validate columns
        for col_key in ["x_column", "y_column", "color_column", "size_column", "facet_row", "facet_col"]: # Added more potential keys
            col_name = suggestion_dict.get(col_key)
            if col_name and col_name not in available_columns:
                 logger.warning(f"LLM suggested column '{col_name}' (for {col_key}) not found. Setting to None.")
                 suggestion_dict[col_key] = None

        logger.info(f"Visualization suggestion received and validated: {suggestion_dict}")
        return suggestion_dict

    except Exception as e:
        logger.error(f"Visualization suggestion failed: {e}", exc_info=True)
        return {"error": f"Failed to get/process visualization suggestion: {e}"}


def create_plotly_chart(
    df: pd.DataFrame,
    suggestion: Dict[str, Any],
    custom_config: Optional[Dict[str, Any]] = None # For UI overrides
    ) -> go.Figure:
    """
    Creates a Plotly chart based on the DataFrame, an AI suggestion, and optional user overrides.

    Args:
        df: Pandas DataFrame containing the data.
        suggestion: Dictionary like {'chart_type': 'bar', 'x_column': 'region', ...}
        custom_config: Optional dictionary allowing override of suggested params
                       (e.g., {'chart_type': 'line', 'color_column': 'segment'}).

    Returns:
        A Plotly Figure object. Returns an empty figure on error.
    """
    if df is None or df.empty:
        logger.warning("Cannot create chart: DataFrame is empty.")
        fig = go.Figure().update_layout(title_text="No data available for visualization")
        return fig

    # --- Apply Custom Overrides ---
    chart_params = suggestion.copy() # Start with suggestion
    if custom_config:
        logger.info(f"Applying custom chart config: {custom_config}")
        chart_params.update(custom_config) # Override suggestion with user choices

    # --- Extract Parameters ---
    chart_type = chart_params.get("chart_type")
    x = chart_params.get("x_column")
    y = chart_params.get("y_column")
    color = chart_params.get("color_column")
    size = chart_params.get("size_column") # Example: For bubble charts
    facet_row = chart_params.get("facet_row") # Example: For faceted charts
    facet_col = chart_params.get("facet_col") # Example: For faceted charts
    # Add more parameters as needed (hover_data, labels, etc.)

    fig = None
    title = f"{chart_type.capitalize() if chart_type else 'Chart'}" # Default title

    logger.info(f"Creating '{chart_type}' chart. X='{x}', Y='{y}', Color='{color}', Size='{size}', Facets='{facet_row}/{facet_col}'")

    try:
        # --- Validate Columns (based on effective params) ---
        if not chart_type: raise ValueError("Chart type not specified.")
        valid_columns = list(df.columns)
        for col_key, col_name in [('X',x), ('Y',y), ('Color',color), ('Size',size), ('Facet Row',facet_row), ('Facet Col',facet_col)]:
             if col_name and col_name not in valid_columns: raise ValueError(f"{col_key}-axis/encoding column '{col_name}' not found.")
        # Basic requirements check (can be enhanced)
        if chart_type in ["bar", "line", "scatter", "box", "violin", "density_heatmap", "density_contour", "scatter_3d", "line_3d"] and (not x or not y):
            raise ValueError(f"{chart_type.capitalize()} requires X and Y columns.")
        if chart_type == "histogram" and not x: raise ValueError("Histogram requires X column.")
        if chart_type == "pie" and (not x or not y): raise ValueError("Pie requires names (X) and values (Y).")
        if chart_type in ["treemap", "sunburst"] and not chart_params.get("path"): # Hierarchical need path
             # Try setting path automatically if possible? For now, require it.
             raise ValueError(f"{chart_type.capitalize()} requires 'path' parameter (list of columns).")


        # --- Prepare Plotly Express Arguments ---
        plot_args = {"data_frame": df.copy()} # Work on copy
        if x: plot_args["x"] = x
        if y: plot_args["y"] = y
        if color: plot_args["color"] = color
        if size: plot_args["size"] = size
        if facet_row: plot_args["facet_row"] = facet_row
        if facet_col: plot_args["facet_col"] = facet_col
        # Pass other potential args from chart_params if they match px function args
        if chart_params.get("hover_name"): plot_args["hover_name"] = chart_params["hover_name"]
        if chart_params.get("hover_data"): plot_args["hover_data"] = chart_params["hover_data"]
        if chart_params.get("labels"): plot_args["labels"] = chart_params["labels"] # Dict for custom labels
        if chart_params.get("log_x"): plot_args["log_x"] = chart_params["log_x"] # Boolean
        if chart_params.get("log_y"): plot_args["log_y"] = chart_params["log_y"] # Boolean
        if chart_params.get("range_x"): plot_args["range_x"] = chart_params["range_x"] # List [min, max]
        if chart_params.get("range_y"): plot_args["range_y"] = chart_params["range_y"] # List [min, max]
        if chart_params.get("color_discrete_sequence"): plot_args["color_discrete_sequence"] = chart_params["color_discrete_sequence"] # List of colors
        if chart_params.get("color_continuous_scale"): plot_args["color_continuous_scale"] = chart_params["color_continuous_scale"] # Plotly scale name


        # Determine title more dynamically
        base_title = "Chart"
        if chart_type == "histogram": base_title = f"Distribution of {x}"
        elif chart_type == "pie": base_title = f"Composition by {x}"
        elif y and x : base_title = f"{y} by {x}"
        elif x: base_title = f"Data by {x}"
        elif y: base_title = f"Data by {y}"
        if color: base_title += f" (Color: {color})"
        if size: base_title += f" (Size: {size})"
        plot_args["title"] = base_title

        # --- Generate Plot ---
        if chart_type == "bar": fig = px.bar(**plot_args)
        elif chart_type == "line": fig = px.line(**plot_args)
        elif chart_type == "scatter": fig = px.scatter(**plot_args)
        elif chart_type == "pie": fig = px.pie(names=x, values=y, **{k:v for k,v in plot_args.items() if k not in ['x','y']}) # Use names/values
        elif chart_type == "histogram": fig = px.histogram(**{k:v for k,v in plot_args.items() if k != 'y'})
        elif chart_type == "box": fig = px.box(**plot_args)
        elif chart_type == "violin": fig = px.violin(**plot_args)
        elif chart_type == "density_heatmap": fig = px.density_heatmap(**plot_args)
        elif chart_type == "density_contour": fig = px.density_contour(**plot_args)
        elif chart_type == "scatter_3d": fig = px.scatter_3d(**plot_args) # Requires z column
        elif chart_type == "line_3d": fig = px.line_3d(**plot_args) # Requires z column
        elif chart_type == "scatter_geo": # Requires lat/lon or location names
             plot_args.pop('x', None); plot_args.pop('y', None) # Geo uses different location params
             fig = px.scatter_geo(**plot_args)
        elif chart_type == "choropleth": # Requires locations and geojson/scope
             plot_args.pop('x', None); plot_args.pop('y', None)
             fig = px.choropleth(**plot_args)
        elif chart_type == "treemap": # Requires path (list of cols), values
             plot_args.pop('x', None); plot_args.pop('y', None)
             fig = px.treemap(**plot_args) # Must have 'path', 'values' in params
        elif chart_type == "sunburst": # Requires path (list of cols), values
             plot_args.pop('x', None); plot_args.pop('y', None)
             fig = px.sunburst(**plot_args) # Must have 'path', 'values' in params
        else:
            raise ValueError(f"Chart type '{chart_type}' is listed as supported but generation logic is missing.")

        # --- Post-Generation Customization & Layout Refinements ---
        if fig:
            logger.info(f"Successfully generated Plotly '{chart_type}' chart.")
            fig.update_layout(
                title_text=plot_args["title"], # Set title explicitly
                title_x=0.5, # Center title
                margin=dict(l=20, r=20, t=50, b=20), # Adjust margins
                legend_title_text=color if color else None # Set legend title if color used
            )
            # Add hover improvements?
            # fig.update_traces(hovertemplate=...)

        else: raise RuntimeError(f"Chart generation unexpectedly resulted in 'None'.")

        return fig

    except Exception as e:
        logger.error(f"Error creating Plotly chart ({chart_type=}): {e}", exc_info=True)
        fig = go.Figure()
        fig.update_layout(title_text=f"Chart Error ({chart_type=}): {e}")
        return fig

# --- Helper to Recreate Figure from JSON ---
def figure_from_json(figure_json: Union[str, Dict]) -> Optional[go.Figure]:
    """Safely tries to load a Plotly Figure from its JSON representation."""
    if not figure_json: return None
    try:
        if isinstance(figure_json, str):
            return go.Figure(json.loads(figure_json))
        elif isinstance(figure_json, dict):
             # Newer plotly versions might allow direct dict loading with read_json or similar
             # For broader compatibility, convert dict back to json string first
             return go.Figure(json.loads(json.dumps(figure_json)))
        else:
             logger.error(f"Invalid type for figure_json: {type(figure_json)}")
             return None
    except Exception as e:
        logger.error(f"Failed to recreate Plotly figure from JSON: {e}", exc_info=True)
        return None